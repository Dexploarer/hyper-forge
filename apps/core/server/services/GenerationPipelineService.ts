/**
 * Generation Pipeline Service
 * Manages persistent storage and retrieval of generation pipelines
 * IMPORTANT: Matches actual database structure from migration 0023_loud_shen.sql
 */

import { db } from "../db/db";
import { logger } from "../utils/logger";
import {
  generationPipelines,
  type GenerationPipeline,
  type NewGenerationPipeline,
} from "../db/schema";
import { eq, and, lt, desc } from "drizzle-orm";

export interface PipelineConfig {
  description: string;
  assetId: string;
  name: string;
  type: string;
  subtype: string;
  generationType?: string;
  style?: string;
  quality?: string;
  enableRigging?: boolean;
  enableRetexturing?: boolean;
  enableSprites?: boolean;
  materialPresets?: unknown[];
  referenceImage?: unknown;
  riggingOptions?: unknown;
  customPrompts?: unknown;
  metadata?: unknown;
  user?: {
    userId: string;
    walletAddress?: string;
    isAdmin?: boolean;
  };
  visibility?: string;
  tier?: number;
}

export interface StageResult {
  status: "pending" | "processing" | "completed" | "failed" | "skipped";
  progress: number;
  result?: unknown;
  error?: string;
}

export interface Pipeline {
  id: string;
  config: PipelineConfig;
  status: "initializing" | "processing" | "completed" | "failed" | "cancelled";
  progress: number;
  stages: {
    textInput: StageResult;
    promptOptimization: StageResult;
    imageGeneration: StageResult;
    image3D: StageResult;
    textureGeneration: StageResult;
    rigging?: StageResult;
    spriteGeneration?: StageResult;
  };
  results: Record<string, unknown>;
  currentStage?: string;
  error?: string;
  errorStage?: string;
  errorDetails?: unknown;
  createdAt: string;
  startedAt?: string;
  completedAt?: string;
  updatedAt: string;
  expiresAt?: string;
}

export class GenerationPipelineService {
  /**
   * Create a new generation pipeline
   * @param id - UUID for the pipeline (generated by caller)
   * @param config - Pipeline configuration
   */
  async createPipeline(
    id: string,
    config: PipelineConfig,
  ): Promise<GenerationPipeline> {
    // Require authentication - users must be logged in to generate
    if (!config.user?.userId) {
      throw new Error(
        "Authentication required: You must be logged in to generate assets",
      );
    }

    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + 24); // Pipelines expire after 24 hours

    // Store config and initial results in JSONB
    const results = {};

    const newPipeline: NewGenerationPipeline = {
      id, // Use provided UUID
      userId: config.user.userId,
      assetId: null, // Will be set when asset is created
      config: config as unknown as any,
      status: "initializing",
      progress: 0,
      currentStage: null,
      error: null,
      errorStage: null,
      errorDetails: null,
      results,
      meshyTaskId: null,
      riggingTaskId: null,
      expiresAt,
    };

    try {
      const [pipeline] = await db
        .insert(generationPipelines)
        .values(newPipeline)
        .returning();
      return pipeline;
    } catch (error: any) {
      // Enhanced error logging for database constraint violations
      const errorMessage = error?.message || String(error);
      const errorCode = error?.code || error?.errno || error?.sqlState;
      const errorDetail = error?.detail || error?.message;

      logger.error(
        {
          err: {
            pipelineId: id,
            assetId: config.assetId,
            userId: config.user.userId,
            error: errorMessage,
            code: errorCode,
            constraint: error?.constraint,
            detail: errorDetail,
            hint: error?.hint,
          },
        },
        "[GenerationPipelineService] Failed to create pipeline:",
      );

      // Check for foreign key violation (user_id constraint)
      const isForeignKeyViolation =
        errorCode === "23503" ||
        errorMessage?.includes("foreign key") ||
        errorMessage?.includes("violates foreign key") ||
        errorMessage?.includes("user_id");

      if (isForeignKeyViolation) {
        throw new Error(
          `User not found: ${config.user.userId}. Please ensure you are logged in with a valid account.`,
        );
      }

      // Check for unique constraint violation
      if (
        errorCode === "23505" ||
        errorMessage?.includes("unique constraint") ||
        errorMessage?.includes("duplicate key")
      ) {
        throw new Error(`Pipeline ID already exists: ${id}. Please try again.`);
      }

      // Re-throw with original message for other errors
      throw new Error(
        `Failed to create generation pipeline: ${errorMessage || "Unknown database error"}`,
      );
    }
  }

  /**
   * Get a pipeline by ID
   */
  async getJobById(id: string): Promise<GenerationPipeline | null> {
    const [job] = await db
      .select()
      .from(generationPipelines)
      .where(eq(generationPipelines.id, id))
      .limit(1);

    return job || null;
  }

  /**
   * Alias for getJobById for backwards compatibility
   */
  async getJobByPipelineId(
    pipelineId: string,
  ): Promise<GenerationPipeline | null> {
    return this.getJobById(pipelineId);
  }

  /**
   * Get all pipelines for a user
   */
  async getUserJobs(userId: string, limit = 50): Promise<GenerationPipeline[]> {
    return await db
      .select()
      .from(generationPipelines)
      .where(eq(generationPipelines.userId, userId))
      .orderBy(desc(generationPipelines.createdAt))
      .limit(limit);
  }

  /**
   * Update pipeline status and progress
   * @param pipelineId - Pipeline ID (UUID)
   * @param updates - Fields to update
   */
  async updateJob(
    pipelineId: string,
    updates: {
      status?:
        | "initializing"
        | "processing"
        | "completed"
        | "failed"
        | "cancelled";
      progress?: number;
      currentStage?: string;
      results?: Record<string, unknown>;
      error?: string;
      errorStage?: string;
      errorDetails?: unknown;
      meshyTaskId?: string;
      riggingTaskId?: string;
      assetId?: string;
      completedAt?: Date;
      startedAt?: Date;
    },
  ): Promise<GenerationPipeline | null> {
    // Map to actual database columns
    const updateData: Partial<NewGenerationPipeline> = {
      ...(updates.status && { status: updates.status }),
      ...(updates.progress !== undefined && { progress: updates.progress }),
      ...(updates.currentStage && { currentStage: updates.currentStage }),
      ...(updates.results && { results: updates.results as any }),
      ...(updates.error && { error: updates.error }),
      ...(updates.errorStage && { errorStage: updates.errorStage }),
      ...(updates.errorDetails && {
        errorDetails: updates.errorDetails as any,
      }),
      ...(updates.meshyTaskId && { meshyTaskId: updates.meshyTaskId }),
      ...(updates.riggingTaskId && { riggingTaskId: updates.riggingTaskId }),
      ...(updates.assetId && { assetId: updates.assetId }),
      ...(updates.completedAt && { completedAt: updates.completedAt }),
      ...(updates.startedAt && { startedAt: updates.startedAt }),
      updatedAt: new Date(),
    };

    const [job] = await db
      .update(generationPipelines)
      .set(updateData)
      .where(eq(generationPipelines.id, pipelineId))
      .returning();

    return job || null;
  }

  /**
   * Convert GenerationPipeline (database) to Pipeline (API format)
   */
  jobToPipeline(job: GenerationPipeline): Pipeline {
    // Extract stages from config JSONB if present, otherwise use default
    const config = job.config as any;
    const stages = (config.stages || {
      textInput: { status: "completed", progress: 100 },
      promptOptimization: { status: "pending", progress: 0 },
      imageGeneration: { status: "pending", progress: 0 },
      image3D: { status: "pending", progress: 0 },
      textureGeneration: { status: "pending", progress: 0 },
    }) as Pipeline["stages"];

    return {
      id: job.id,
      config: job.config as unknown as PipelineConfig,
      status: job.status,
      progress: job.progress,
      stages,
      results: (job.results || {}) as Record<string, unknown>,
      currentStage: job.currentStage || undefined,
      error: job.error || undefined,
      errorStage: job.errorStage || undefined,
      errorDetails: job.errorDetails || undefined,
      createdAt: job.createdAt.toISOString(),
      startedAt: job.startedAt?.toISOString(),
      completedAt: job.completedAt?.toISOString(),
      updatedAt: job.updatedAt.toISOString(),
      expiresAt: job.expiresAt?.toISOString(),
    };
  }

  /**
   * Clean up expired pipelines
   */
  async cleanupExpiredJobs(): Promise<number> {
    const result = await db
      .delete(generationPipelines)
      .where(
        and(
          lt(generationPipelines.expiresAt, new Date()),
          eq(generationPipelines.status, "completed"),
        ),
      )
      .returning({ id: generationPipelines.id });

    return result.length;
  }

  /**
   * Delete old failed pipelines (older than 7 days)
   */
  async cleanupOldFailedJobs(): Promise<number> {
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    const result = await db
      .delete(generationPipelines)
      .where(
        and(
          lt(generationPipelines.createdAt, sevenDaysAgo),
          eq(generationPipelines.status, "failed"),
        ),
      )
      .returning({ id: generationPipelines.id });

    return result.length;
  }
}

// Export singleton instance
export const generationPipelineService = new GenerationPipelineService();
